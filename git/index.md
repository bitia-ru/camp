# !!! СТАТЬЯ НАХОДИТСЯ В ПРОЦЕССЕ НАПИСАНИЯ

# Git

# Для кого эта статья или пререквизиты

Эта статья подойдет для читателя любого уровня.

# Что такое VCS и зачем это нужно?

_VCS_ - это...

# Предварительная настройка

## Установка

### Windows

### Linux

Ubuntu: `sudo apt install git`

### MacOS

Вам потребуется установить [brew](https://brew.sh/).

```shell script
brew install git
```

## Настройка редактора

Windows:

```shell script
git config --global core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"
```

Ubuntu:

```shell script
git config --global core.editor "TODO"
```

MacOS:

```shell script
git config --global core.editor "TODO"
```

# Манера изложения

# Модель Git

# Интерфейс Git

## Взаимодействие с пользователем через редактор

TODO: Новичкам непривычен этот метод, описать.

## Коммиты

Коммит - это diff + metadata.

Делаем коммит.

### Редактирование последнего коммита
### Редактирование не последних коммитов
### Удаленные репозитории
### Push изменений на удаленный репозиторий
### Force-push

## ref'ы

ref - указатель на коммит или другой ref.

## Мерж-коммиты

## Разрешение конфликтов

TODO: Как понять, в каких файлах конфликты?
TODO: Как понять содержимое файлов, которые надо разрезолвить?

```
<<<<<<<
...
=======
...
>>>>>>>
```

# Два метода ведения репозитория

Плюсы и минусы каждого метода.

## Хронологический метод (merge)

## Логический метод (rebase)

### Подводные камни банального pull'а

Допустим, мы хотим забрать с удаленного сервера новые коммиты в текущую ветку. Мы уже знаем, что для
этого надо выполнить в командной строке вот это:

```
git pull
```

Однако тут кроется одна тонкость: если удаленную ветку ребейзили, то она уже не совсем "наша": 
состав коммитов и даже их содержимое могло поменяться. По сути git находит общее основание у нашей
ветки и ее удаленного первоисточника и объединяет их путем добавления мерж-коммита.

А, как мы сказали выше, в логическом методе ведения репозитория в идеале не должно быть ни одного
мерж-коммита. Как быть? По смыслу нам нужно сделать следующее: сохранить те коммиты, которые в
данной ветке сделали мы сами и подменить все остальные на коммиты из ветки-источника. `git pull`
приводит к появлению мерж-коммитов, значит про эту команду надо забыть (позже мы узнаем, как 
все-таки можно продолжать им пользоваться, но пока будем считать, что это невозможно).

Вместо `git pull` сначала мы выполняем `git fetch`. Это команда не трогает все локальные ветки, а
обновляет только удаленные, поэтому ее можно смело выполнять в любой ситуации. После нее git может
сказать, может ли он считать вашу локальную копию и удаленный первоисточник все еще одной веткой.

Допустим, нам повезло и никто не правил коммиты и/или их набор в удаленной ветке. Тогда мы увидим
следующее:

```
On branch master
Your branch is behind 'origin/master' by 3 commits, and can be fast-forwarded.
  (use "git pull" to update your local branch)

nothing to commit, working tree clean
```

Можно ориентироваться на ключевую фразу `can be fast-forwarded`. Она означает, что наша ветка и
удаленная все еще одна и та же ветка для git'а и pull просто переставит указатель нашей локальной
ветки на несколько коммитов "выше".

Если же вы увидели такое сообщение:

```
On branch master
Your branch and 'origin/master' have diverged,
and have 6 and 8 different commits each, respectively.
  (use "git pull" to merge the remote branch into yours)

nothing to commit, working tree clean
```

Значит все не так радужно: удаленная ветка и наша разошлись несколько коммитов назад, при этом в
вашей ветке с момента расхождения значится 6 коммитов, а в удаленной 8 - т.е. коммиты удаленной
ветки правились и есть еще не менее двух новых коммитов. Триггерной фразой здесь является `have
diverged`. В такой ситуации мы делаем следующее. Нам
нужно сделать ручной ребейз нашей ветки на удаленную, вот так (предполагаем, что мы находимся в
ветке `master`, удаленный первоисточник которой - `origin/master`):

```
git rebase -i origin/master
```

Обратите внимание, что это нужно делать **после выполнения `git fetch`**, чтобы `origin/master` 
приобрел актуальный вид. Откроется файл, в нем мы увидим примерно такую картину:

```
pick 4ebaee3 Other old changed commit
pick 17fd684 Own commit
```

Каждая строчка здесь - это один коммит, по которому от вас требуется решение, что с ним делать:
оставить или удалить. По сообщениям к коммитам мы должны понять, какие из указанных коммитов наши;
в данном случае коммит 17fd684 - наш, с его строчкой мы ничего не делаем. А вот второй явно не наш -
в этой ветке мы его не создавали. Откуда он здесь оказался? Вспомним, как работает `git rebase`:
когда мы говорим git'у "отребейзь текущую ветку на ветку A", он берет самый первый коммит в текущей 
ветке и самый первый коммит в ветке А. Если эти коммиты совпадают, он переходит ко вторым коммитам в
этих ветках. Допустим на сей раз они не совпадают. В этом случае git предлагает нам решить, что 
сделать с коммитом нашей ветки, которого нет в ветке A. Его можно оставить (pick) или
удалить (drop). Есть и другие опции, но сейчас они нам не интересны.

Кажется, что все сложно. Но на самом деле для нашей конкретной ситуации, которую мы сейчас 
разбираем, все просто: если мы дропнем все, кроме тех коммитов, которые мы сами создали в текущей
ветке, и оставим все созданные, мы получим ровно то, что нам нужно: git подменит все коммиты до
наших коммитами из удаленной ветки и оставит наши. Для этого надо привести указанные выше две 
строчки в такой вид (обратите внимание на слово **drop**):

```
drop 4ebaee3 Other old changed commit
pick 17fd684 Own commit
```

И сохранить файл. Если нам повезло, мы увидим такое сообщение:

```
Successfully rebased and updated refs/heads/master.
```

Оно означает, что ребейз выполнился успешно, теперь мы имеем ветку, ровно такую же, как удаленная,
только с нашим коммитом - можно пушить, например. Для проверки можно снова выполнить `git status`
и увидеть заветную фразу `can be fast-forwarded`. Но нам может не повезти и мы увидим такое:

```
Auto-merging some_file.js
CONFLICT (content): Merge conflict in some_file.js
error: could not apply 17fd684... Own commit
```

Это означает, что файл `some_file.js` изменения которого есть в нашем коммите, так же изменился и
в удаленной ветке, причем таким образом, что git не смог выполнит слияние этих изменений. Их 
придется выполнить вручную.

...
